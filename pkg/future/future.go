package future

import (
	"fmt"
	"reflect"
	"sync"

	"golang.org/x/net/context"
)

var (
	nilFuture  = &nilf{}
	closedChan chan struct{} // always closed
)

func init() {
	closedChan = make(chan struct{})
	close(closedChan)
}

// allows callers to wait for the completion of some function.
// carries completion signal, safe for use across concurrent goroutines.
type Interface interface {
	// when future has "completed" this channel will be closed
	Done() <-chan struct{}
	// error associated with execution of some function, valid after the Done channel is closed
	Err() error
	// marks this future as discarded, which transtions the future to a terminal state, and no longer ready.
	Discard()
	// when the future has been discarded this channel will be closed
	Discarded() <-chan struct{}
	// result generated by a func, valid after the Done channel is closed
	Result() interface{}
	// Installs a callback that is executed when this future is ready and
	// associates the result of the callback with the future that is returned
	// to the caller
	Later(func(interface{}) Interface) Interface
}

func doLater(r Interface, callback func(interface{}) Interface) Interface {
	ch := make(chan Interface, 1)
	OnReady(r, func(priorResult interface{}) {
		ch <- callback(priorResult)
	})
	return &delegate{incoming: ch}
}

type delegate struct {
	readOnce sync.Once
	incoming <-chan Interface
	other    Interface
}

func (d *delegate) fill() Interface {
	d.readOnce.Do(func() {
		if other, ok := <-d.incoming; ok {
			d.other = other
		} else {
			// programming
			panic("incoming channel closed without presenting a future")
		}
	})
	return d.other
}

func (d *delegate) Done() <-chan struct{} {
	return d.fill().Done()
}

func (d *delegate) Err() error {
	return d.fill().Err()
}

func (d *delegate) Discarded() <-chan struct{} {
	return d.fill().Discarded()
}

func (d *delegate) Discard() {
	d.fill().Discard()
}

func (d *delegate) Result() interface{} {
	return d.fill().Result()
}

func (d *delegate) Later(callback func(interface{}) Interface) Interface {
	// executes async so we don't want to fill() here
	return doLater(d, callback)
}

type nilf struct{}

func (d *nilf) Done() <-chan struct{} {
	return closedChan
}

func (d *nilf) Err() error {
	return nil
}

func (d *nilf) Discarded() <-chan struct{} {
	return closedChan
}

func (d *nilf) Discard() {
	// noop
}

func (d *nilf) Result() interface{} {
	return nil
}

func (d *nilf) Later(callback func(interface{}) Interface) Interface {
	return nilFuture
}

type returned struct {
	err         error
	done        chan struct{}
	discard     chan struct{}
	discardOnce sync.Once
	doneOnce    sync.Once
	result      interface{}
}

func (r *returned) Result() interface{} {
	return r.result
}

func (r *returned) Later(callback func(interface{}) Interface) Interface {
	return doLater(r, callback)
}

func (r *returned) Discarded() <-chan struct{} {
	return r.discard
}

func (r *returned) Discard() {
	r.discardOnce.Do(func() {
		close(r.discard)
		r.markDone(DiscardedBeforeDoneError)
	})
}

func (r *returned) Done() <-chan struct{} {
	return r.done
}

func (r *returned) Err() error {
	return r.err
}

func newReturned() *returned {
	return &returned{
		done:    make(chan struct{}),
		discard: make(chan struct{}),
	}
}

func New(ptrToType interface{}, f func() (interface{}, error)) Interface {
	r := newReturned()
	go r.exec(ptrToType, f)
	return r
}

func NewWithContext(ctx context.Context, ptrToType interface{}, f func(context.Context) (interface{}, error)) Interface {
	r := newReturned()
	go r.exec(ptrToType, func() (interface{}, error) { return f(ctx) })
	return r
}

func (r *returned) exec(ptrToType interface{}, f func() (interface{}, error)) {
	var reportedError error
	defer func() { r.markDone(reportedError) }() // lazy eval of reportedError

	spectype, err := enforcePtr(ptrToType)
	if err != nil {
		reportedError = err
		return
	}

	r.result, reportedError = f()
	if resulttype, err := enforcePtr(r.result); err != nil {
		// result is allowed to be of a <nil> type only if the spectype is compatible with
		// those documented in reflect.Value.IsNil()
		if err == nilTypeError {
			switch spectype.Kind() {
			case reflect.Chan, reflect.Func, reflect.Interface, reflect.Map, reflect.Ptr, reflect.Slice:
				return
			}
		}
		reportedError = err
	} else if spectype != resulttype {
		reportedError = fmt.Errorf("expected result of type %v instead of type %v", spectype, resulttype)
	}
}

func (r *returned) markDone(err error) {
	r.doneOnce.Do(func() {
		defer close(r.done)
		r.err = err
	})
}

// EnforcePtr ensures that obj is a pointer of some sort. Returns a reflect.Type
// of the pointer type. The pointer may be nil. Returns an error if this is not possible.
// HACK(jdef) hacked from https://github.com/GoogleCloudPlatform/kubernetes/blob/release-0.8/pkg/conversion/meta.go
func enforcePtr(obj interface{}) (t reflect.Type, err error) {
	v := reflect.ValueOf(obj)
	if v.Kind() == reflect.Invalid {
		err = nilTypeError
	} else {
		t = v.Type()
	}
	return
}
