package future

import (
	"fmt"
	"reflect"
	"sync"

	"golang.org/x/net/context"
)

var (
	nilFuture  = &nilf{}
	closedChan chan struct{} // always closed
)

func init() {
	closedChan = make(chan struct{})
	close(closedChan)
}

// allows callers to wait for the completion of some function.
// carries completion signal, safe for use across concurrent goroutines.
type Interface interface {
	// when future has "completed" this channel will be closed
	Done() <-chan struct{}
	// error associated with execution of some function, valid after the Done channel is closed
	Err() error
	// marks this future as discarded, which transtions the future to a terminal state, and no longer ready.
	Discard()
	// when the future has been discarded this channel will be closed
	Discarded() <-chan struct{}
	// result generated by a func, valid after the Done channel is closed
	Result() interface{}
	// Installs a callback that is executed when this future is ready and
	// associates the result of the callback with the future that is returned
	// to the caller
	Later(func(interface{}) Interface) Interface
	// Installs a callback that is executed when this future is ready and
	// associates the result of the callback with the future that is returned
	// to the caller
	Then(func(interface{}) (interface{}, error)) Interface
}

func doThen(r Interface, callback func(interface{}) (interface{}, error)) Interface {
	type t struct {
		i interface{}
		e error
	}
	ch := make(chan *t, 1)
	OnReady(r, func(priorResult interface{}) {
		defer close(ch)
		val := &t{}
		val.i, val.e = callback(priorResult)
		ch <- val
	})
	// wildcard future spec type allows any result type
	return New(nil, func() (interface{}, error) {
		if val, ok := <-ch; !ok {
			//programming error
			panic("channel closed before presenting a result")
		} else {
			return val.i, val.e
		}
	})
}

func doLater(r Interface, callback func(interface{}) Interface) Interface {
	ch := make(chan Interface, 1)
	OnReady(r, func(priorResult interface{}) {
		defer close(ch)
		ch <- callback(priorResult)
	})
	return &delegate{incoming: ch}
}

type delegate struct {
	readOnce sync.Once
	incoming <-chan Interface
	other    Interface
}

func (d *delegate) fill() Interface {
	d.readOnce.Do(func() {
		if other, ok := <-d.incoming; ok {
			d.other = other
		} else {
			// programming error
			panic("incoming channel closed before presenting a future")
		}
	})
	return d.other
}

func (d *delegate) Done() <-chan struct{} {
	return d.fill().Done()
}

func (d *delegate) Err() error {
	return d.fill().Err()
}

func (d *delegate) Discarded() <-chan struct{} {
	return d.fill().Discarded()
}

func (d *delegate) Discard() {
	d.fill().Discard()
}

func (d *delegate) Result() interface{} {
	return d.fill().Result()
}

func (d *delegate) Later(callback func(interface{}) Interface) Interface {
	// executes async so we don't want to fill() here
	return doLater(d, callback)
}

func (d *delegate) Then(callback func(interface{}) (interface{}, error)) Interface {
	// executes async so we don't want to fill() here
	return doThen(d, callback)
}

type nilf struct{}

func (d *nilf) Done() <-chan struct{} {
	return closedChan
}

func (d *nilf) Err() error {
	return nil
}

func (d *nilf) Discarded() <-chan struct{} {
	return closedChan
}

func (d *nilf) Discard() {
	// noop
}

func (d *nilf) Result() interface{} {
	return nil
}

func (d *nilf) Later(callback func(interface{}) Interface) Interface {
	return nilFuture
}

func (d *nilf) Then(callback func(interface{}) (interface{}, error)) Interface {
	return nilFuture
}

type returned struct {
	err         error
	done        chan struct{}
	discard     chan struct{}
	discardOnce sync.Once
	doneOnce    sync.Once
	result      interface{}
}

func (r *returned) Result() interface{} {
	return r.result
}

func (r *returned) Later(callback func(interface{}) Interface) Interface {
	return doLater(r, callback)
}

func (r *returned) Then(callback func(interface{}) (interface{}, error)) Interface {
	return doThen(r, callback)
}

func (r *returned) Discarded() <-chan struct{} {
	return r.discard
}

func (r *returned) Discard() {
	r.discardOnce.Do(func() {
		close(r.discard)
		r.markDone(DiscardedBeforeDoneError)
	})
}

func (r *returned) Done() <-chan struct{} {
	return r.done
}

func (r *returned) Err() error {
	return r.err
}

func newReturned() *returned {
	return &returned{
		done:    make(chan struct{}),
		discard: make(chan struct{}),
	}
}

func New(ptrToType interface{}, f func() (interface{}, error)) Interface {
	r := newReturned()
	go r.exec(ptrToType, f)
	return r
}

func NewWithContext(ctx context.Context, ptrToType interface{}, f func(context.Context) (interface{}, error)) Interface {
	r := newReturned()
	go r.exec(ptrToType, func() (interface{}, error) { return f(ctx) })
	return r
}

func (r *returned) exec(ptrToType interface{}, f func() (interface{}, error)) {
	var reportedError error
	defer func() { r.markDone(reportedError) }() // lazy eval of reportedError

	r.result, reportedError = f()

	sv := reflect.ValueOf(ptrToType)
	rv := reflect.ValueOf(r.result)

	if rv.Kind() == reflect.Invalid {
		switch sv.Kind() {
		// result is allowed to be of a <nil> type only if the spec value kind is compatible with
		// nillable types (mainly those documented in reflect.Value.IsNil())
		case reflect.Chan, reflect.Func, reflect.Interface,
			reflect.Map, reflect.Ptr, reflect.Slice, reflect.Invalid:

		// zero-values allowed for most other kinds
		case reflect.Bool, reflect.Uintptr, reflect.Struct, reflect.String, reflect.Array,
			reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,
			reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64,
			reflect.Float32, reflect.Float64, reflect.Complex64, reflect.Complex128:
			r.result = reflect.Zero(sv.Type()).Interface()

		default:
			reportedError = nilTypeError
		}
		return
	} else if sv.Kind() == reflect.Invalid {
		// spec was <nil>, but we have a non-<nil> result: interpret this as
		// "caller specified a wildcard result type, so anything goes"
	} else if spectype, resulttype := sv.Type(), rv.Type(); spectype != resulttype {
		// spec and result are both non-nil and the types don't match
		reportedError = newTypeError(fmt.Sprintf("expected result of type %v instead of type %v", spectype, resulttype))
	}
}

func (r *returned) markDone(err error) {
	r.doneOnce.Do(func() {
		defer close(r.done)
		r.err = err
	})
}
